import axios from 'axios';
import logger from '../util/logger';
import { GEMINI_API_HOST, GEMINI_MODEL } from '../config/constants';
import { GeminiResponse } from '../types/ai';
import {
  AiRecipeData,
  AiRecipeRequestBody,
  defaultAiIngredients,
} from '../types/recipe';

export class AiRecipeService {
  constructor(private readonly apiKey = process.env.GEMINI_API_KEY) {}

  async generateRecipe(body: AiRecipeRequestBody): Promise<AiRecipeData> {
    const ingredients = body.ingredients?.length
      ? body.ingredients
      : defaultAiIngredients;

    if (!this.apiKey) {
      throw new Error(
        'GEMINI_API_KEY is not set. Please add it to your backend .env file.'
      );
    }

    const tomlPayload = this.buildTomlPayload(ingredients);
    const prompt = this.buildPrompt(tomlPayload);

    const url = `${GEMINI_API_HOST}/${GEMINI_MODEL}:generateContent?key=${this.apiKey}`;

    logger.info('Requesting Gemini recipe generation', { model: GEMINI_MODEL });

    const { data } = await axios.post<GeminiResponse>(
      url,
      {
        contents: [
          {
            parts: [{ text: prompt }],
          },
        ],
      },
      {
        headers: {
          'Content-Type': 'application/json',
        },
      }
    );

    const recipe = this.extractRecipeText(data);

    if (!recipe) {
      throw new Error('Gemini returned an empty response.');
    }

    return {
      ingredients: ingredients.map(ingredient =>
        this.formatDisplayIngredient(ingredient)
      ),
      prompt,
      recipe,
      model: data.modelVersion ?? GEMINI_MODEL,
    };
  }

  private buildPrompt(toml: string): string {
    return [
      'You are the virtualfridge.ai culinary assistant.',
      'Craft a single, approachable recipe that uses only the provided ingredients. If common pantry staples (oil, salt, pepper) are needed you may include them.',
      'Return the recipe in Markdown with the following sections: Title (H2), Ingredients (list), Steps (numbered list), and a short Serving Suggestion paragraph.',
      'Do not mention that this was generated by AI.',
      'Input specification is provided as TOML. Use the ingredient `name` values for display.',
      '```toml',
      toml,
      '```',
    ].join('\n\n');
  }

  private buildTomlPayload(ingredients: string[]): string {
    const lines = [
      'title = "Virtual Fridge Recipe Request"',
      'version = "1.0"',
      '',
    ];

    ingredients.forEach((ingredient, index) => {
      lines.push('[[ingredients]]');
      lines.push(`id = "${index + 1}"`);
      lines.push(`key = "${ingredient}"`);
      lines.push(`name = "${this.formatDisplayIngredient(ingredient)}"`);
      lines.push('');
    });

    lines.push('[request]');
    lines.push('style = "Family friendly"');
    lines.push(
      'goal = "Create one complete recipe that highlights the provided ingredients."'
    );

    return lines.join('\n');
  }

  private extractRecipeText(response: GeminiResponse): string | null {
    const firstCandidate = response.candidates?.[0];
    if (!firstCandidate?.content?.parts) {
      return null;
    }

    const text = firstCandidate.content.parts
      .map(part => part.text?.trim())
      .filter(Boolean)
      .join('\n\n')
      .trim();

    return text || null;
  }

  private formatDisplayIngredient(raw: string): string {
    const cleaned = raw.replace(/[_-]+/g, ' ').trim().toLowerCase();

    return cleaned
      .split(' ')
      .filter(Boolean)
      .map(part => part[0].toUpperCase() + part.slice(1))
      .join(' ');
  }
}
